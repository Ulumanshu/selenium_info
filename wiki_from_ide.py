# Generated by Selenium IDE
import pytest
import time
import json
from selenium import webdriver
from selenium.webdriver.firefox.firefox_binary import FirefoxBinary
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.firefox.firefox_binary import FirefoxBinary
from multiprocessing import Process #, Condition

class GridControll():

    def __init__(self, max_nodes = 1):
        self.max_nodes = max_nodes
        self.processes = list()
        # self.condition = Condition()

    def count_processes_by_driver(self, driver_type):
        return len([p for p in self.processes if driver_type in p.name])

    def get_process_by_driver(self, driver_type):
        target_process = False
        for p in self.processes:
            if driver_type in p.name:
                target_process = p
                break
        
        return target_process
    
    def remove_inactive_processes(self):
        for nr, process in enumerate(self.processes):
            if not process.is_alive():               
                process.join()
                self.processes.pop(nr)

    def start(self, method, driver_type):
        p_check = [p for p in self.processes if driver_type in p.name ]
        if len(p_check) < self.max_nodes:
            self.spawn_process(method, driver_type)
            time.sleep(2)
        else:
            self.teardown_method(driver_type)
            self.start(method, driver_type)

    def teardown_method(self, driver_type):        
        last_process_by_driver = self.get_process_by_driver(driver_type)
        if last_process_by_driver:
            last_process_by_driver.join()
            self.processes.remove(last_process_by_driver)
            time.sleep(2)
               
        self.remove_inactive_processes()

    def spawn_process(self, method, driver_type):
        p_count = self.count_processes_by_driver(driver_type)
        p = Process(target=method, name=f"{driver_type} - {p_count + 1}")
        p.start()
        print("SPAWN !!!: ", f"{driver_type} - {p_count + 1}", method)
        self.processes.append(p)
    
class TestExample():
   
    def __init__(
        self,
        driver,
        grid_remote='http://127.0.0.1:4444/wd/hub',
        local=False
    ):
        self.adpater = {
            "firefox": {
                "desired_capabilities": {
                    'browserName': 'firefox', 'javascriptEnabled': True
                }
            },
            "chrome": {
                "desired_capabilities": {
                    'browserName': 'chrome', 'javascriptEnabled': True
                }
            }            
        }
        self.local = local
        self.remote = grid_remote
        self.desired_capabilities = self.adpater.get(driver, dict()).get('desired_capabilities') or\
            not self.local and {'browserName': 'firefox', 'javascriptEnabled': True} or False

    def adopt_driver(self):
        if self.local:
            self.driver = webdriver.Firefox()
        else:
            self.driver = webdriver.Remote(
                command_executor=self.remote,
                desired_capabilities=self.desired_capabilities
            )    

    def teardown_method(self):
        self.driver.quit()
    
    def print_headers(self):
        for nr, header in enumerate(self.driver.find_elements(By.TAG_NAME, "h2")):
            print(f"HEADER {nr + 1}: {header.text}")

    def test_pigu(self):
        """Method witch sequentially opens urls from targeted pigu.lt table
        Urls are opened using webdriver.
        """
        self.adopt_driver()
        self.driver.get('https://pigu.lt/lt/')
        self.driver.set_window_size(1024, 900)
        time.sleep(2)
        products = self.driver.find_elements(By.CLASS_NAME, "product-item-inner")
        for product in products:
            self.driver.execute_script("arguments[0].scrollIntoView();", product)
            price_tag = product.find_element_by_class_name("price.notranslate").text
            label = product.find_element_by_class_name("product-name").text
            time.sleep(1)
            print(f"Product: {label}, Costs: {price_tag} !")
        self.teardown_method()
    
    def test_wiki(self):
        """Method witch sequentially opens urls from targeted wikipedia table

        Urls are opened using webdriver.
        """
        self.adopt_driver()
        # Uzkraunamas pirmas puslapis
        self.driver.get("https://www.wikipedia.org/")
        self.driver.set_window_size(1024, 900)
        time.sleep(1)
        # Parenkama anglu kalba
        self.driver.find_element(By.CSS_SELECTOR, "#js-link-box-en > strong").click()
        time.sleep(1)
        # Search laukelyje surekama Lietuva ir paspaudziama lupa
        self.driver.find_element(By.ID, "searchInput").send_keys("Lietuva")
        self.driver.find_element(By.ID, "searchButton").click()
        time.sleep(1)
        # Isaugom kur grysti
        search_res_url = self.driver.current_url
        # Surenkam adresus is lenteles i kuria nusitaikyta xpathu
        # Uzsiemimu metu dazna klaida kad bandyta loopinti per pacius elementus(selenium objektus)
        # jie nustoja veikti pakeitus puslapi {jie praranda veiksnuma}
        # Xpath is lenteles kurios klase ir stilius kaip nurodyti paimti
        # visus elmentus kurie turi href atributa
        urls = [
            e.get_attribute('href') for e in self.driver.find_elements(
                By.XPATH,
                "//table[@class='wikitable' and @style='text-align:center;']//*[@href]"
            )
        ]
        for url in urls:
            try:                
                print(f"Visited: {url}")
                # Keiciamas adresas, naudojamas java scriptas
                self.driver.execute_script(
                    f'''window.open("{url}","_self");'''
                )
                time.sleep(2)
                # Atspaudinamos lankomo psl antrashtes
                self.print_headers()
            except:
                continue

        time.sleep(2)
        print(f"Visited: {search_res_url}")
        # Pradinis puslapis sugrazinamas
        self.driver.execute_script(
            f'''window.open("{search_res_url}","_self");'''
        )
        time.sleep(5)
        self.teardown_method()


if __name__ == "__main__":
    controll = GridControll()
    wikiff = TestExample("firefox")
    wikic = TestExample("chrome")
    controll.start(wikiff.test_wiki, 'ff')
    controll.start(wikic.test_pigu, 'ch')
    controll.start(wikic.test_wiki, 'ch')
    controll.start(wikiff.test_pigu, 'ff')
    controll.start(wikiff.test_wiki, 'ff')
    controll.start(wikic.test_pigu, 'ch')
    controll.start(wikic.test_wiki, 'ch')
    controll.start(wikiff.test_pigu, 'ff')
    
    