# Generated by Selenium IDE
import pytest
import time
import json
from selenium import webdriver
from selenium.webdriver.firefox.firefox_binary import FirefoxBinary
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.firefox.firefox_binary import FirefoxBinary
from multiprocessing import Process

class GridControll():

    def __init__(self, driver_type, max_nodes = 2):
        self.driver_type = driver_type
        self.max_nodes = max_nodes
        self.processes = list()

    def p_count(self):
        return len(self.processes)

    def remove_inactive_processes(self):
        for nr, process in enumerate(self.processes):
            if process.is_alive():               
                continue

            process.join()
            self.processes.pop(nr)

    def process(self, object, methods):
        valid_methods = self.validate_methods(object, methods)
        p = Process(
            target=self.run_methods,
            name=f"{self.driver_type} controller",
            args=(valid_methods, )
        )
        p.start()
        print("SPAWN CONTROLER!!!: ", f"{self.driver_type} - {object}", methods)
        return p
    
    def validate_methods(self, object, methods):
        return [getattr(object, m) for m in methods if hasattr(object, m)]

    def run_methods(self, methods):
        for method in methods:
            self.start(method)
            time.sleep(2)
    
    def start(self, method):
        self.remove_inactive_processes()
        if len(self.processes) < self.max_nodes:
            self.spawn_process(method)
            time.sleep(1)
        else:
            self.teardown_method()
            self.start(method)

    def teardown_method(self):
        self.remove_inactive_processes()
        time.sleep(5)

    def spawn_process(self, method):
        p = Process(target=method, name=f"{self.driver_type} - {self.p_count()}")
        p.start()
        print("SPAWN !!!: ", f"{self.driver_type} - {self.p_count()}", method)
        self.processes.append(p)
    
class TestExample():
   
    def __init__(
        self,
        driver,
        grid_remote='http://127.0.0.1:4444/wd/hub',
        local=False
    ):
        self.adpater = {
            "firefox": {
                "desired_capabilities": {
                    'browserName': 'firefox', 'javascriptEnabled': True
                }
            },
            "chrome": {
                "desired_capabilities": {
                    'browserName': 'chrome', 'javascriptEnabled': True
                }
            }            
        }
        self.local = local
        self.remote = grid_remote
        self.driver_name = driver
        self.desired_capabilities = self.adpater.get(driver, dict()).get('desired_capabilities') or\
            not self.local and {'browserName': 'firefox', 'javascriptEnabled': True} or False

    def adopt_driver(self):
        if self.local:
            self.driver = webdriver.Firefox()
        else:
            self.driver = webdriver.Remote(
                command_executor=self.remote,
                desired_capabilities=self.desired_capabilities
            )    

    def teardown_method(self):
        self.driver.quit()
    
    def print_headers(self):
        for nr, header in enumerate(self.driver.find_elements(By.TAG_NAME, "h2")):
            print(f"HEADER {nr + 1}: {header.text}")

    def test_pigu(self):
        """Method witch sequentially opens urls from targeted pigu.lt table
        Urls are opened using webdriver.
        """
        self.adopt_driver()
        self.driver.get('https://pigu.lt/lt/')
        self.driver.set_window_size(1024, 900)
        time.sleep(2)
        products = self.driver.find_elements(By.CLASS_NAME, "product-item-inner")
        for product in products:
            self.driver.execute_script("arguments[0].scrollIntoView();", product)
            price_tag = product.find_element_by_class_name("price.notranslate").text
            label = product.find_element_by_class_name("product-name").text
            time.sleep(1)
            print(f"Product: {label}, Costs: {price_tag} !")
        self.teardown_method()
    
    def test_wiki(self):
        """Method witch sequentially opens urls from targeted wikipedia table

        Urls are opened using webdriver.
        """
        self.adopt_driver()
        # Uzkraunamas pirmas puslapis
        self.driver.get("https://www.wikipedia.org/")
        self.driver.set_window_size(1024, 900)
        time.sleep(1)
        # Parenkama anglu kalba
        self.driver.find_element(By.CSS_SELECTOR, "#js-link-box-en > strong").click()
        time.sleep(1)
        # Search laukelyje surekama Lietuva ir paspaudziama lupa
        self.driver.find_element(By.ID, "searchInput").send_keys("Lietuva")
        self.driver.find_element(By.ID, "searchButton").click()
        time.sleep(1)
        # Isaugom kur grysti
        search_res_url = self.driver.current_url
        # Surenkam adresus is lenteles i kuria nusitaikyta xpathu
        # Uzsiemimu metu dazna klaida kad bandyta loopinti per pacius elementus(selenium objektus)
        # jie nustoja veikti pakeitus puslapi {jie praranda veiksnuma}
        # Xpath is lenteles kurios klase ir stilius kaip nurodyti paimti
        # visus elmentus kurie turi href atributa
        urls = [
            e.get_attribute('href') for e in self.driver.find_elements(
                By.XPATH,
                "//table[@class='wikitable' and @style='text-align:center;']//*[@href]"
            )
        ]
        for nr, url in enumerate(urls):
            if nr < 3:
                try:                
                    print(f"Visited: {url}")
                    # Keiciamas adresas, naudojamas java scriptas
                    self.driver.execute_script(
                        f'''window.open("{url}","_self");'''
                    )
                    time.sleep(2)
                    # Atspaudinamos lankomo psl antrashtes
                    self.print_headers()
                except:
                    continue

        time.sleep(2)
        print(f"Visited: {search_res_url}")
        # Pradinis puslapis sugrazinamas
        self.driver.execute_script(
            f'''window.open("{search_res_url}","_self");'''
        )
        time.sleep(5)
        self.teardown_method()


if __name__ == "__main__":

    # GRID EXAMPLE

    ff = TestExample("firefox")
    ch = TestExample("chrome")
    ff_controll = GridControll(ff.driver_name)
    ch_controll = GridControll(ch.driver_name)   
    ff_prc = ff_controll.process(
        ff,
        [
            'test_pigu',
            'test_pigu',
            'test_pigu',
            'test_pigu',
            'test_wiki',
            'test_wiki',
            'test_wiki',
            'test_wiki'           
        ]
    )
    ch_prc = ch_controll.process(
        ch,
        [
            'test_wiki',
            'test_wiki',
            'test_wiki',
            'test_wiki',
            'test_pigu',
            'test_pigu',
            'test_pigu',
            'test_pigu'                    
        ]
    )

    ff_prc.join()
    print(f"Joined {ff_prc.name}")
    ch_prc.join()
    print(f"Joined {ch_prc.name}")
    
    # LOCAL EXAMPLE

    loc_ff = TestExample("localhost", local=True)
    loc_controll = GridControll(loc_ff.driver_name)
    loc_prc = loc_controll.process(
        loc_ff,
        [
            'test_wiki',
            'test_wiki',
            'test_wiki',
            'test_wiki',
            'test_pigu',
            'test_pigu',
            'test_pigu',
            'test_pigu'                    
        ]
    )

    loc_prc.join()
    print(f"Joined {loc_prc.name}")
