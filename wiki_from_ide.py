# Generated by Selenium IDE
import pytest
import time
import json
from selenium import webdriver
from selenium.webdriver.firefox.firefox_binary import FirefoxBinary
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.firefox.firefox_binary import FirefoxBinary
from multiprocessing import Process


processes = list()

def remote_firefox_setup():
    return webdriver.Remote(
        command_executor='http://127.0.0.1:4444/wd/hub',
        desired_capabilities={'browserName': 'firefox', 'javascriptEnabled': True}
    )

def remote_chrome_setup():
    return webdriver.Remote(
        command_executor='http://127.0.0.1:4444/wd/hub',
        desired_capabilities={'browserName': 'chrome', 'javascriptEnabled': True}
    )

def local_firefox_setup():
    return webdriver.Firefox()


class TestWiki():
    def setup_method(self, method):
        self.driver = method()
        self.vars = {}

    def teardown_method(self):
        self.driver.quit()

    def print_headers(self):
        for nr, header in enumerate(self.driver.find_elements(By.TAG_NAME, "h2")):
            print(f"HEADER {nr + 1}: {header.text}")

    def test_wiki(self):
        """Method witch sequentially opens urls from targeted wikipedia table

        Urls are opened using webdriver.
        """
        # Uzkraunamas pirmas puslapis
        self.driver.get("https://www.wikipedia.org/")
        time.sleep(1)
        # Parenkama anglu kalba
        self.driver.find_element(By.CSS_SELECTOR, "#js-link-box-en > strong").click()
        time.sleep(1)
        # Search laukelyje surekama Lietuva ir paspaudziama lupa
        self.driver.find_element(By.ID, "searchInput").send_keys("Lietuva")
        self.driver.find_element(By.ID, "searchButton").click()
        time.sleep(1)
        # Isaugom kur grysti
        search_res_url = self.driver.current_url
        # Surenkam adresus is lenteles i kuria nusitaikyta xpathu
        # Uzsiemimu metu dazna klaida kad bandyta loopinti per pacius elementus(selenium objektus)
        # jie nustoja veikti pakeitus puslapi {jie praranda veiksnuma}
        # Xpath is lenteles kurios klase ir stilius kaip nurodyti paimti
        # visus elmentus kurie turi href atributa
        urls = [
            e.get_attribute('href') for e in self.driver.find_elements(
                By.XPATH,
                "//table[@class='wikitable' and @style='text-align:center;']//*[@href]"
            )
        ]
        for url in urls:
            try:                
                print(f"Visited: {url}")
                # Keiciamas adresas, naudojamas java scriptas
                self.driver.execute_script(
                    f'''window.open("{url}","_self");'''
                )
                time.sleep(2)
                # Atspaudinamos lankomo psl antrashtes
                self.print_headers()
            except:
                continue

        time.sleep(2)
        print(f"Visited: {search_res_url}")
        # Pradinis puslapis sugrazinamas
        self.driver.execute_script(
            f'''window.open("{search_res_url}","_self");'''
        )
        time.sleep(5)
        self.teardown_method()


def spawn_process(method):
    p = Process(target=method)
    p.start()
    processes.append(p)

if __name__ == "__main__":
    wikiff = TestWiki()
    wikiff.setup_method(remote_firefox_setup)
    wikic = TestWiki()
    wikic.setup_method(remote_chrome_setup) 
    spawn_process(wikiff.test_wiki)
    spawn_process(wikic.test_wiki)
    
